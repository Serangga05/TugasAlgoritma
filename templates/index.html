<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GCL Lexical Scanner — Flask</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Prism for syntax highlight -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

  <!-- D3 for AST visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    pre.codebox {
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
      border-radius: 8px;
      padding: 12px;
    }
    /* AST panel */
    #ast-svg { width:100%; height:400px; border-radius:8px; background: white; }
  </style>
</head>
<body class="bg-gradient-to-br from-sky-50 to-blue-100 min-h-screen p-8">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white rounded-2xl shadow-lg p-6">
      <h1 class="text-2xl font-bold text-blue-700 mb-2">GCL Lexical Scanner & Mini Compiler</h1>
      <p class="text-sm text-gray-600 mb-4">Scanner dibuat di backend (Flask). Parser sederhana menghasilkan AST dan dapat mengekspor ke PDF.</p>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div>
          <label class="font-semibold">Input GCL Code</label>
          <textarea id="code" class="w-full p-3 border rounded-lg mt-2 h-48 font-mono" spellcheck="false">
// contoh:
if B -> x := 1 fi

// contoh guarded:
if x > 0 -> y := y + 1 | x <= 0 -> y := y - 1 fi
          </textarea>

          <div class="flex gap-2 mt-4">
            <button id="btnScan" onclick="doScan()" class="px-4 py-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700">Scan</button>
            <button id="btnParse" onclick="doParse()" class="px-4 py-2 bg-indigo-600 text-white rounded shadow hover:bg-indigo-700">Parse</button>
            <button id="btnPdf" onclick="doPdf()" class="px-4 py-2 bg-gray-700 text-white rounded shadow hover:bg-gray-800">Export PDF</button>
            <button onclick="highlightCode()" class="px-3 py-2 border rounded text-gray-700">Highlight</button>
          </div>

          <div class="mt-4">
            <label class="font-semibold">Highlighted Source</label>
            <pre class="codebox"><code id="highlight" class="language-javascript"></code></pre>
          </div>
        </div>

        <div>
          <label class="font-semibold">Tokens</label>
          <div id="tokensPanel" class="mt-2 grid grid-cols-1 gap-2"></div>

          <label class="font-semibold mt-4 block">Parser & AST</label>
          <div id="parseInfo" class="mt-2 text-sm text-gray-700"></div>
          <svg id="ast-svg"></svg>
        </div>
      </div>

      <div class="mt-6 bg-slate-50 p-4 rounded">
        <h3 class="font-semibold mb-2">Notes</h3>
        <ul class="list-disc pl-5 text-sm text-gray-700">
          <li>Scanner reports tokens with line & column information.</li>
          <li>Parser returns error with token position for easier debugging.</li>
          <li>Exported PDF includes token list and AST JSON.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
async function doScan(){
  const code = document.getElementById('code').value;
  const form = new FormData();
  form.append('code', code);

  document.getElementById('tokensPanel').innerHTML = `<div class="p-3 bg-yellow-50 rounded">Scanning...</div>`;
  const res = await fetch('/scan', { method:'POST', body: form });
  const tokens = await res.json();
  renderTokens(tokens);
  // also show highlighted source
  document.getElementById('highlight').textContent = code;
  Prism.highlightElement(document.getElementById('highlight'));
}

function renderTokens(tokens){
  const panel = document.getElementById('tokensPanel');
  panel.innerHTML = '';
  if(!tokens || tokens.length===0){
    panel.innerHTML = `<div class="p-3 bg-green-50 rounded">No tokens</div>`;
    return;
  }
  tokens.forEach(t => {
    const color = t.type === 'ERROR' ? 'bg-red-100 border-red-300' : 'bg-white border';
    const html = `<div class="p-3 ${color} rounded shadow-sm border-gray-200">
      <div class="flex justify-between items-start">
        <div>
          <div class="font-semibold">${escapeHtml(t.value)}</div>
          <div class="text-xs text-gray-500">${t.type} • line ${t.line}, col ${t.col}</div>
        </div>
        <div class="text-xs text-gray-600">${t.index}</div>
      </div>
    </div>`;
    panel.insertAdjacentHTML('beforeend', html);
  });
}

async function doParse(){
  const code = document.getElementById('code').value;
  const form = new FormData();
  form.append('code', code);
  document.getElementById('parseInfo').innerText = 'Parsing...';

  const res = await fetch('/parse', { method:'POST', body: form });
  if(res.status === 200){
    const data = await res.json();
    document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-green-50 rounded">Parse OK — AST generated</div>`;
    renderAST(data.ast);
    // ensure tokens displayed
    if(data.tokens) renderTokens(data.tokens);
  } else {
    const err = await res.json();
    document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-red-50 rounded">Parse Error: ${escapeHtml(err.message || 'Unknown')}</div>`;
    if(err.token) {
      document.getElementById('parseInfo').innerHTML += `<div class="text-xs text-gray-600 mt-2">At token: ${escapeHtml(JSON.stringify(err.token))}</div>`;
    }
    // still show tokens if returned
    if(err.tokens) renderTokens(err.tokens);
  }
}

async function doPdf(){
  const code = document.getElementById('code').value;
  const form = new FormData();
  form.append('code', code);
  // download PDF
  const res = await fetch('/export_pdf',{ method:'POST', body: form });
  if(!res.ok){
    alert('Failed to generate PDF');
    return;
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'gcl_report.pdf';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function highlightCode(){
  const code = document.getElementById('code').value;
  document.getElementById('highlight').textContent = code;
  Prism.highlightElement(document.getElementById('highlight'));
}

// ------------------- AST visualization with D3 -------------------
function renderAST(ast){
  // simple conversion from AST JSON to tree nodes
  const root = convertAstToTree(ast);
  drawTree(root);
}

function convertAstToTree(ast){
  // produce nodes with {name, children}
  function nodeify(obj){
    if (obj === null || typeof obj === 'undefined') return {name: 'null'};
    if (typeof obj === 'string' || typeof obj === 'number' || obj.node === undefined) {
      return {name: String(obj)};
    }
    const name = obj.node || (obj.type || 'Node');
    const children = [];
    for(const k of Object.keys(obj)){
      if(k === 'node') continue;
      const v = obj[k];
      if(Array.isArray(v)){
        children.push({name: k, children: v.map(nodeify)});
      } else if(typeof v === 'object'){
        children.push({name: k, children: [nodeify(v)]});
      } else {
        children.push({name: `${k}: ${v}`});
      }
    }
    return {name, children};
  }
  return nodeify(ast);
}

function drawTree(root){
  const svg = d3.select("#ast-svg");
  svg.selectAll("*").remove();
  const width = svg.node().clientWidth || 900;
  const height = svg.node().clientHeight || 400;

  const g = svg.append("g").attr("transform","translate(20,20)");
  const treeLayout = d3.tree().size([height-40, width-100]);
  const hierarchyData = d3.hierarchy(root, d => d.children || []);
  const tree = treeLayout(hierarchyData);

  // links
  g.selectAll('path.link')
    .data(tree.links())
    .enter()
    .append('path')
    .attr('class','link')
    .attr('d', d3.linkHorizontal()
                 .x(d => d.y)
                 .y(d => d.x))
    .attr('fill','none')
    .attr('stroke','#888')
    .attr('stroke-width',1.2);

  // nodes
  const node = g.selectAll('g.node')
    .data(tree.descendants())
    .enter()
    .append('g')
    .attr('transform', d => `translate(${d.y},${d.x})`);

  node.append('circle').attr('r',6).attr('fill','#2563eb');
  node.append('text')
    .attr('dx', 10)
    .attr('dy', 4)
    .text(d => d.data.name)
    .style('font-size','12px');
}

// small utility
function escapeHtml(str){
  if(!str) return '';
  return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
}

// initialize highlight
document.getElementById('highlight').textContent = document.getElementById('code').value;
Prism.highlightElement(document.getElementById('highlight'));
</script>
</body>
</html>
